<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="static/d3.min.js"></script>
  <!-- <script src="https://peterbeshai.com/d3-interpolate-path/d3-interpolate-path.js"></script> -->
  <style>
    .axisBottom path {
      stroke-width: 2px;
      stroke: #777777;
    }

    .axisBottom line {
      stroke-width: 2px;
      stroke: #777777;
    }

    .axisBottom text {
      fill: #777777;
      font-weight: bold;
      font-size: 12px;
      transform: "rotate(-50)";
    }

    .axisLeft path {
      stroke-width: 2px;
      stroke: #777777;
    }

    .axisLeft .tick {
      display: none;
    }

    .axisLeft text {
      display: none;
    }

    .axis path,
    .axis line {
      shape-rendering: crispEdges;
    }

    .grid line {
      stroke: #444444;
      stroke-opacity: 0.7;
      stroke-width: 2px;
      stroke-dasharray: 8, 6;
      /* shape-rendering: crispEdges; */
    }

    .grid path {
      stroke-width: 0;
    }

    .streamsvg{
      -webkit-filter: drop-shadow(6px 6px 2px rgba(0,0,0,0.5));      
      filter: drop-shadow(6px 6px 5px rgba(0,0,0,0.6));
    }
  </style>
</head>

<body>
  <div class="container"></div>
</body>
<script>
  var margin = { top: 80, bottom: 80, left: 80, right: 120 };
  var svgWidth = 1040;
  var svgHeight = 550;

  var width = svgWidth - margin.left - margin.right;
  var height = svgHeight - margin.top - margin.bottom;

  var svg = d3.select('.container')
    .append('svg')
    .attr('class', 'streamsvg')
    .attr('width', svgWidth)
    .attr('height', svgHeight);

  var svg2 = d3.select('.container')
    .append('svg')
    .attr('transform',"translate(" + 0+ "," + (-svgHeight) + ")")
    .attr('width', svgWidth)
    .attr('height', svgHeight);

  // filters go in defs element
var defs = svg.append("defs");

// create filter with id #drop-shadow
// height=130% so that the shadow is not clipped
var filter = defs.append("filter")
    .attr("id", "drop-shadow")
    .attr("height", "120%");

// SourceAlpha refers to opacity of graphic that this filter will be applied to
// convolve that with a Gaussian with standard deviation 3 and store result
// in blur
filter.append("feDropShadow")
    .attr("dx", "12")
    .attr("dy", '12')
    .attr("stdDeviation", "3")
    .attr('flood-color','#333333');

// // translate output of Gaussian blur to the right and downwards with 2px
// // store result in offsetBlur
// filter.append("feOffset")
//     .attr("in", "blur")
//     .attr("dx", 2)
//     .attr("dy", 2)
//     .attr("result", "offsetBlur");

// // overlay original SourceGraphic over translated blurred opacity by using
// // feMerge filter. Order of specifying inputs is important!
// var feMerge = filter.append("feMerge");

// feMerge.append("feMergeNode")
//     .attr("in", "offsetBlur")
// feMerge.append("feMergeNode")
//     .attr("in", "SourceGraphic");

  var g = svg.append("g")
    .attr('class', 'streamsvg')
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var g2 = svg2.append("g")
    .attr('class', 'streamsvg')
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // extra svg to clip the graph and x axis as they transition in and out
  var graph = g.append("svg")
    .attr('class', 'streamsvg')
    .attr("width", width+2)
    .attr("height", height + margin.top + margin.bottom);

  var graph2 = g2.append("svg")
    .attr('class', 'streamsvg')
    .attr("width", width+2)
    .attr("height", height + margin.top + margin.bottom);


  // scale
  var x = d3.scaleTime()
    .domain([new Date(2016, 0), new Date(2018, 9)])
    .range([0, width + width / 11 * 22]);

  var y = d3.scaleLinear()
    .range([height, 0]);
  var color = d3.scaleOrdinal()
    .domain(d3.range(0, 4, 1))
    .range(['#a3a1a1', '#28AF63', '#0165bf', '#FFD700'])

  var xnow = d3.scaleTime()
    .domain([new Date(2016, 0), new Date(2016, 11)])
    .range([0, width]);
  // axises
  var xAxis = d3.axisBottom(xnow)
    // .tickSizeInner(-height + 40)
    .tickFormat(d => {
      if (d - new Date(2016, 5, 23) === 0) return d3.timeFormat("%m-%d")(d);
      if (d.getMonth() === 0) return d3.timeFormat("%Y-%m")(d);
      else { return d3.timeFormat("%m")(d); }
    });

  var yAxis = d3.axisLeft(y);

  let newTicks = xnow.ticks(d3.timeMonth);
  newTicks.push(new Date(2016, 5, 23));
  xAxis.tickValues(newTicks);

  graph2.append("g")
    .attr("transform", `translate(0,${height})`)
    .attr("class", "axisBottom")
    .style("font", "12px Helvetica Neue")
    .call(xAxis)
    .selectAll("text")
    .style("text-anchor", "start")
    .attr("y", 0)
    .attr("x", 9)
    .attr("dy", ".35em")
    .attr("transform", "rotate(50)");

  function parseDate(str) {
    var y = str.substr(0, 4),
      m = str.substr(4, 2) - 1,
      d = str.substr(6, 2);
    if (d) return new Date(y, m, d);
    return new Date(y, m);
  }

  function sortIndex(array, i) {
    let tmp = array.concat();
    tmp.sort((a, b) => (a[i][1] - a[i][0] - (b[i][1] - b[i][0])));
    let index = [];
    tmp.forEach(d => {
      index.push(array.indexOf(d));
    })
    return index;
  }

  d3.csv('static/data/hashtag_stream.csv').then(function (data) {
    var dataArray = [];
    var keys = [];

    var originData = []
    data.forEach(d => {
      let word = d.hashtag.trim();
      keys.push(word);
      for (let label in d) {
        if (label !== 'hashtag') {
          let tmp = {};
          tmp.key = word;
          tmp.date = label;
          tmp.value = parseInt(d[label]);
          originData.push(tmp);
        }
      }
    });

    function stackMax(layer) {
      return d3.max(layer, function (d) { return d[1]; });
    }

    function stackMin(layer) {
      return d3.min(layer, function (d) { return d[0]; });
    }

    function seperate(layers, index) {
      let len = layers.length;
      return layers[len - 1][index][1] - layers[0][index][0];
    }

    var nestData = d3.nest()
      .key(d => d.date)
      .entries(originData);

    nestData.forEach(d => {
      let tmp = {};
      tmp.date = d.key;
      d.values.forEach(dd => {
        tmp[dd.key] = dd.value;
      });
      dataArray.push(tmp);
    });

    dataArray.sort((a, b) => parseDate(a.date) - parseDate(b.date));
    var dataArray2 = dataArray.filter((d, i) => i % 1 === 0);
    var stack = d3.stack()
      .keys(keys)
      .order(d3.stackOrderNone)

    var layers = stack(dataArray2);
    var timeLen = dataArray2.length;
    var dataTypeNum = layers.length;

    var ymin = d3.min(layers, stackMin);
    var ymax = d3.max(layers, stackMax);

    var sepLen = 25; // 每条线的间隔

    var textData = [];
    for (let i = 0; i < timeLen; i++) {
      let index = sortIndex(layers, i);
      let sep = seperate(layers, i); // i时间点的竖线宽度
      let extraSpace = sepLen * (dataTypeNum - 1);
      let totalLen = sep + extraSpace;
      if (i === 0) {
        let start = - totalLen / 2;
        let now = start;
        let sepLen0 = ((ymax - ymin - 200) - sep) / (dataTypeNum - 1);
        for (let j = 0; j < dataTypeNum; j++) {
          let ii = index[j];
          let tmp = layers[ii][0][1] - layers[ii][0][0];
          layers[ii][0][0] = now;
          layers[ii][0][1] = now + tmp;
          textData.push({ "text": layers[ii].key, "y": now, "type": j })
          layers[ii].type = j;
          now = now + tmp + sepLen;
        }
      } else {
        let start = - totalLen / 2;
        let now = start;
        for (let j = 0; j < dataTypeNum; j++) {
          let ii = index[j];
          let tmp = layers[ii][i][1] - layers[ii][i][0];
          layers[ii][i][0] = now;
          layers[ii][i][1] = now + tmp;
          now = now + tmp + sepLen;
        }
      }
    }

    ymin = d3.min(layers, stackMin) * 1.1;
    ymax = d3.max(layers, stackMax) * 1.1;
    y.domain([ymin, ymax]);

    var area = d3.area()
      .x(function (d) { return x(parseDate(d.data.date)); })
      .y0(function (d) { return y(d[0]) })
      .y1(function (d) { return y(d[1]) })
      .curve(d3.curveCardinal);

    var stream = graph.selectAll(".stream")
      .data(layers)
      .enter().append("path")
      .attr('class', "stream")
      .attr('class', 'streamsvg')
      // .style("filter", "url(#drop-shadow)")
      // .attr('filter','url(#f4)')
      // .attr('clip-path','url(#myClip)')
      .attr("d", area)
      .style("fill-opacity", 0.8)
      .style("fill", d => color(d.type))
      .style('stroke', '#fefefe').style('stroke-width', 1)
      .style('stroke-opacity', 0.8);

    stream.attr("opacity", 1)
      .on("mouseover", function (d, i) {
        svg.selectAll(".stream").transition()
          .duration(250)
          .attr("opacity", function (d, j) {
            return j != i ? 0.2 : 1;
          })
      })
      .on("mouseout", function (d, i) {
        svg.selectAll(".stream")
          .transition()
          .duration(250)
          .attr("opacity", 1);
      })


    svg2.selectAll(".label")
      .data(textData)
      .enter().append('text')
      .attr('class', 'label')
      .attr("x", width + margin.left + 30)
      .attr("y", (d,i) => 25*i + margin.top + 5)
      .text(d => d.text)
      .style('text-transform', 'capitalize')
      .style('fill', '#555555')
      .attr("font-family", "sans-serif")
      .attr("text-anchor", "start")
      .attr("font-size", 16)
      .attr('font-weight', 900);


    svg2.selectAll('.colorLabel')
       .data(textData)
       .enter().append('circle')
       .attr('class','colorLabel')
       .attr('cx',width+margin.left+20)
       .attr('cy',(d,i) => 25*i + margin.top)
       .attr('r',6)
       .style("fill-opacity", 0.8)
       .style('fill',d=>color(d.type))
       .style('stroke','#444444')
       .style('stroke-width',1)

    var timecount = 0;
    var tmplayers = layers[0].filter((d) => d.data.date !== '20160623')



  // gridlines in x axis function
  function make_x_gridlines() {		
      return d3.axisBottom(xnow)
          .tickValues([new Date(2016,5,23)])
  }
  // add the X gridlines
  var grid = graph2.append("g")			
      .attr("class", "grid")
      .attr("transform", `translate(0,${height})`)
      .call(make_x_gridlines()
          .tickSize(-height)
          .tickFormat("")
      )

    const interval = d3.interval((t) => {
      let xTicks = xAxis.tickValues();
      console.log(tmplayers[timecount + 1].data.date);
      var xseperate = xnow(parseDate(tmplayers[timecount + 1].data.date)) - xnow(new Date(2016, 0));
      xnow.domain([parseDate(tmplayers[timecount + 1].data.date), parseDate(tmplayers[timecount + 12].data.date)]);
      xTicks.push(parseDate(tmplayers[timecount + 12].data.date));

      console.log(xseperate);

      xTicks.shift();
      xAxis.tickValues(xTicks);
      var labelText = graph2.select('.axisBottom').transition().duration(1000).ease(d3.easeLinear).call(xAxis);
      graph2.select('.grid').transition().duration(1000).ease(d3.easeLinear).call(d3.axisBottom(xnow)
      .tickValues([new Date(2016,5,23)]).tickSize(-height)
          .tickFormat(""));
      labelText.selectAll('text')
        .style("text-anchor", "start")
        .attr("y", 0)
        .attr("x", 9)
        .attr("dy", ".55em")
        .attr("transform", "rotate(50)");

      stream.transition()
        .duration(1000)
        .ease(d3.easeLinear)
        .attr('transform', 'translate(' + (-xseperate) + ',0)');

      timecount++;
      if (timecount === 22) {
        graph.transition().delay(900).duration(100).attr('width', width + 20);
        interval.stop();
      }
    }, 1000);

    svg2.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`)
      .attr("class", "axisLeft")
      .style("font", "12px Helvetica Neue")
      .call(yAxis)

  });


</script>

</html>